# Kraken Language

[TOC]

## Введение

## Основые понятия

1. **Множество** - базовая деталь языка, на основе которой строятся более сложные конструкции.
2. **Тип** - множество значений, определенных множеством.
3. **Функция** - множество функций или операторов, имеющих возможность выполнятся. 
4. **Модуль** - множество сущностей, которыми могут быть определения новых типов, функций и переменных.

## Множества

Язык позволяет определять множества следующими способами:

```C++
{1, 2, 3, 4, 5} // Построение с явным перечислением всех элементов.
```

```C++
// Построение с сокращенным перечислением.
{1 .. 5} 	// == {1, 2, 3, 4, 5}
{1, 3 .. 5} // == {1, 3, 5}
{5 .. 1} 	// == {5, 4, 3, 2, 1}
```

```C++
// Построение на основе другого множества.
{ x*2 for x <- {1 .. 5} if x > 2 } // == { 6, 8, 9 }
```

```go
// Динамическое создание множеств.
{  for item <- stdin }
```

### Предопределенные множества

```go
Set // = { .. } // Семейство всех множеств.
Any // = { .. } // Множество элементов объединения всех множеств.
```



## Типы

Каждое множество можно использовать как тип данных. Каждый тип данных можно использовать для определения констант и переменных.

```C++
A = {1 .. 3} // Создание множество А. 
a = 1 // Создание константы c именем 'а' и значением '1', которое может быть использовано в любом контексте с типом 'A'.
b: A = 2 // Создание переменной c именем 'b', значением '2' и типом А. 
// После определения переменной 'b' становятся доступны присваивания: 
    b = 1
    b = 2
    b = 3
// Любое другое вызовет ошибку compile- или run-time в зависимости возможности вычисления аргумента. 
```

### Расширения, сужения и преобразования

Определим несколько множеств.

```go
A = {1 .. 10}
B = {1 .. 5}
C = {11, 12}
```

Можно заметить, что все элементы множества *B* также пренадлежат множеству *A*, а значит любую переменную с типом *B* можно расширить до типа *А*, также как и сузить любую переменную с типом *A* до *B*.

Элементы множества *С* никак не связаны с ранее определенными множествами, однако все равно можно определить свою операцию каста.

```go
a: A
b: B
c: C 
// ... 
a = b // Какое бы ни было значение в переменной 'b', оно автоматически расширится до типа 'А'.
b = Narrow a // Требуется явное сужение. Элементы, что нельзя преобразовать, будут иметь значение по умолчанию.
a = Cast c   // Требуется явный каст и его определение.

Narrowable a:set b:set = {
    Narrow x:a : b   
}

Castable a:set b:set = {
    Cast x:a b
}
```



### Предопределенные типы

```C++
Bool = { False, True }

I8 = {-2^7 .. 2^7 - 1}
I16 = { .. }
I32 = { .. }
I64 = { .. }

U8 = {0 .. 2^8 - 1}
U16 = { .. }
U32 = { .. }
U64 = { .. }

R32 = { .. }
R64 = { .. }

Char = { 'a', 'b', .. } // Любой символ unicode.
String = { {'a'}, {'a','b'}, {'a', 'b', 'c'} } // Семейство множеств, в которых каждый элемент является элементом множества 'char'.

"a", "ab", "abc" // Упрощенная запись элементов множества 'string'.
```

### Встроенные структуры данных

#### Кортежи

Язык поддерживает работу с картежами. Пример:

```go
point = (r64, r64) 
x := point.at 0 
y := point.at 1
(x', y') := point 

Person = (name: String, age: U64) // Именнованный картеж.
p: Person
p.name = "Andrey"
p.age  = 23

// Целевая инициализация:
d: Person = { name = "Alexey", age = 22 }
```

#### Массивы

```go
[ Containable t' ]
Array t:t' // Массив элементов с типом t.
 
ArrayType = { Static, Dynamic, List, Auto = default }
```

Структура данных *Array* может иметь одно из трех внутренних преставлений.

1. Статичный массив, т.е. количество элементов постоянное.
2. Динамический массив, т.е. количество элементов непостоянное.
3. Лист.

Представление можно либо задать, либо сдеать автоматически изменяемым в зависимости от того, какие и в каком количество методы будут применятся над объектом.

Пример: 

```go
names: Array String = { "John", "Alex" }
x = names.At 0 // "John"
names.Insert "Morty"
// names.length == 3
 
for name <- names {
    f = Format "Hello, I am {0}!\n" name 
    Stdout f
} 
```

#### Словари

```haskell
Map key:Set val:Set	
```

Пример:

```go
data = {1,2,3,1,1,1,2,3}

m: Map {1,2,3} U32
for item <- data {
    m.Change item \val { val + 1 }  
    // \val { val+1 } == (+1)
}
// m == {1: 4, 2: 2, 3: 2}

x = m.Find 1 // 4
y = m.Find 5 // nil
```



 ## Функции

### Hello World!

Всякая Kraken-программа начинает выполнение с функции с именем *main*. 

```C++
main = {
    Stdout "Hello, World!"
} 
```

#### Синтаксис определения 

```go
sum x:I32 y:I32 : I32 = { // Определение с явным описанием типов.
	x + y				 	  
}

dif x:a' y:a' : a' = { // Определение с шаблонным описанием типов.
    x - y			   // На шаблон a' накладывается ограничение: должна быть определена операция (-): a' a' a'.
}

\x { x+1 } 		// Безымянная функция или лямбда.
(+1)			// Сокращенный вариант предыдущего определения.
```

### Ограничения 

Язык позволяет определять множества функций для семейства типов. 

```go
number x:Set = {
	(+): x x x
	abs: x abs_r
	
	abs_r = { item for item <- x if 0 <= item }
}

// Специализация 'number' для типа I32.
number I32 { 
	(+) x:I32 y:I32 : I32 = {
		x + y
	}
	abs x:I32 : abs_r = {
		x if 0 <= x else -x			
	}
}
```

Множество *abs_r* состоит только из положительных элементов исходного множества *x*, однако требует ограничения на опертор *(<=)* для этого типа элементов. 

### Предопределенные ограничения

```go
Notable a:Set = {
	Not x:a : a 
}

Eq a:Set = {
	(==) x:a y:a Bool = Not (x != y)
	(!=) x:a y:a Bool = Not (x == y)
}

Cmp a:Set = {
	(>) x:a y:a Bool = Not (x < y)
	(<) x:a y:a Bool = Not (x > y)
}

// Определяет для каждого множенства элемент по умолчанию при инициализации переменных.
DefaultInit a:Set = {
	DefaultInit a:Set : a 
}

// Любое множество в языке определяет данное ограничение.
[ Eq a, Strinable a, Iterable a ]
Set a:Set = {
	Card a I64
}
```



## Структуры управления

### Условия

```go
// Если cond == True, то x = y иначе z. Обе ветви обязаны возвращать результат одного типа. cond обязан быть типа Bool.
x := y if cond else z 

// Ветвь 'if' является обязательной, остальные - опциональными.
if cond1 {
	x
} else if cond2 {
    y  
} else {
	z
}

// Ветвь 'else if' является опциональной, а ветви 'if' и 'else' обязательными. Каждая ветвь должна возвращать результат одного типа. 
res := if cond1 {
	x
} else if cond2 {
    y  
} else {
	z
}

// 'a' может иметь любой тип. 'b' и 'c' необязаны быть константами, но должны иметь возможность расшириться до типа сущности 'a'.
res := switch a {
    case b {
        x    
	}
    
	case c = y
   
	default {
        z
    }
}

Person = { name: String, age: U32 }
p: Person // = { ... }
switch p {
	case name, 32 {
    	// Обрабатываем любую сущность типа 'Person' c полем 'age' = 32.   
    }
    case "Andrey", age {
        // Обрабатываем любую сущность типа 'Person' c полем 'name' = "Andrey". 
    }
    case name, age // default.
}
```

#### break и continue	

```go
res = switch cond {
	case 1 {
    	// ...    
    } continue 2 .. 3 // Перейти к выполнению 'case 2 .. 3'.  
	case 2 .. 3 {
        if cond == 3 {
            break res = 1 // Завершить выполнение 'switch' и присвоить 'res' значение '1'.
        } 
    }
}
```

### Циклы

```go
for { } // - бесконечный цикл.

// Чтобы объект можно было перебрать, он должен реализовывать Iterable.
nums: array 3 I32 = { 1, 2, 3, 4, 5 }
for (i, item) <- nums {}

for a <- I8 {
    // Перебирает все элементы множества I8.
}

for cond {
    // Выполняется, пока 'cond' == True.
}
```

#### break и continue	

1. *break* - завершить цикл.

	2. *continue* - завершить действительную итерацию.

#### Вложеные управляющие структуры

Константы и переменные можно использовать, в качестве меток, чтобы указать, к какому именно циклу или условию относится *break* или *continue* 

```go
c1 = for {
	c2 = for {
		continue c2 // Начнет новую итерацию у цикла 2.
        // ...	
		break c1 = 3   // Завершит цикл 1, присвоив константе 'с1' значение 3.
	}
} 
```

Если завершать цикл, не передавая значение, то будет присвоно значение по умолчанию.

## Модули и область видимости

Любой модуль также представляется в виде множества сущеностей любого типа. Модулем следует считать папку с файлами типа *.k*.

Предоположим, что мы имеем следующее состояние директории:

1. my_lib/a.k
2. my_lib/b.k
3. other_lib/c.k

Элементы описанные в файлах *a.k* и *b.k* находятся в общей области видимости и видны друг для друга, в отличии от элементов файла *c.k*, в которых их необходимо импотрировать прежде чем использовать. 

```go
import my_lib 		// Глобальный импорт.
lib = import my_lib // Именованный импорт для избежания колизии имен.
```

Все сущности, начинающиеся на заглавную букву будет импортированы, в отличии от сущностей, чье имя начинается на маленькую букву.

## Рефлексия

Рефлексия подразумевает набор функций для анализа каждой сущности. Мы уже знакомы с набором функций для любого множества. Теперь рассмотрим функции для анализа других сущностей.

```go
[Cast a String]
AnyFunctions a: Any {
    IsConst 	x:a : Bool
    Size 		x:a : Byte 	// Количество байт, занимаемых в памяти.
    Sets		x:a : Set 	// Семейство множеств, которые содержат данный элемент.
    Names		x:a : Set   // Множество имен, которые были у сущности.
    Address 	x:a : Pointer a  
}
```

Примеры:

```go
b: Bool = True

b.IsConst 	// False
b.Size 		// 1 byte
b.Sets		// { Bool }

(Cos 	0).Sets	// Cos 0 = 1 => 1.Sets = { U8, U16, U32, U64, I8, I16, I32, I64, R32, R64 }
(Cos Pi/6).Sets	// Cos Pi/6 = Sqrt(3)/2 => (Sqrt(3)/2).Sets = { R32, R64 }

a : Array I32 = { 1 .. 10 }

foo b:Array I32 : Any = {
    c := b
    d = b
    
    b.Names // == { "a", "b", "d" }
    c.Names // == { "c" }
}

1.Address // == nil
b.Address // Адрес будет зависить от машины.
```

Множество функций для анализа функций.

```go
[AnyFunctions a]
FunctionFunctions a:Any = {
    IsPure 		x:a : Bool // Проверяет, является ли функция чистой.
    Arguments	x:a : Set  // Множество аргументов.
    Instuctions x:a : Set  // Множество действий, которые выполняет функция.
} 
```

Пример:

```go
[Cast a' String]
foo x:U8 y:a' : String = {
 	(x.cast String) + (y.cast String)
}
 
foo 1 " hello" // "1 hello"

foo.IsPure 				// True
foo.Arguments 			// { x, y }
foo.Arguments[1].Sets 	// { a' }  
foo.Constraints 		// { Cast a' String }
foo.Return
```



Множество функций для анализа структур выполнения.

```go
cond: any // = { .. }

a = switch cond {
case 1 		= 3
case "2" 	= 4
case True   {
    // doSomething ...
}
}

a.Condtion // cond
a.Cases // == Map{ (1, 3), ("2", 4), (True, Istructions) }

b = for i <- {0 .. 10} {
    
}

b.Counter // i
b.Instructions // {}
```

### Метапрограммирование

Метапрограммирование подразумевает написание программы, которая при компиляции или выполнении будет писать другую программу.

```go
CreateFunction name arguments instructions 
```







